using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Fixture17
{
    public class Fixture
    {
        public static FixturedRound Round1 { get; private set; }
        public static FixturedRound Round2 { get; private set; }
        public static FixturedRound Round3 { get; private set; }
        public static FixturedRound Round4 { get; private set; }
        public static FixturedRound Round5 { get; private set; }

        public static void Initialise()
        {
            Round1 = new FixturedRound(1);
            Round2 = new FixturedRound(2);
            Round3 = new FixturedRound(3);
            Round4 = new FixturedRound(4);
            Round5 = new FixturedRound(5);
            Round4.AddMatch(0, 1, false, 44010); Round5.AddMatch(0, 5, true, 44017); Round3.AddMatch(0, 7, false, 44003); Round2.AddMatch(0, 12, false, 43995); Round1.AddMatch(0, 15, true, 43911);
            Round2.AddMatch(1, 5, true, 43995); Round1.AddMatch(1, 9, false, 43912); Round5.AddMatch(1, 12, true, 44016); Round3.AddMatch(1, 16, true, 44002);
            Round4.AddMatch(2, 4, false, 44009); Round3.AddMatch(2, 6, false, 44002); Round2.AddMatch(2, 10, true, 43995); Round1.AddMatch(2, 13, false, 43909); Round5.AddMatch(2, 14, true, 44016);
            Round5.AddMatch(3, 4, true, 44015); Round4.AddMatch(3, 8, false, 44008); Round2.AddMatch(3, 13, true, 43993); Round3.AddMatch(3, 14, true, 44002); Round1.AddMatch(3, 17, false, 43910);
            Round1.AddMatch(4, 5, true, 43911); Round3.AddMatch(4, 10, true, 44003); Round2.AddMatch(4, 15, false, 43996);
            Round4.AddMatch(5, 7, false, 44009); Round3.AddMatch(5, 12, true, 44003);
            Round5.AddMatch(6, 7, true, 44016); Round1.AddMatch(6, 8, false, 43911); Round2.AddMatch(6, 9, true, 43994); Round4.AddMatch(6, 10, false, 44010);
            Round1.AddMatch(7, 12, true, 43911); Round2.AddMatch(7, 16, true, 43995);
            Round5.AddMatch(8, 9, true, 44017); Round2.AddMatch(8, 11, true, 43996); Round3.AddMatch(8, 17, false, 44001);
            Round4.AddMatch(9, 11, true, 44010); Round3.AddMatch(9, 13, false, 44000);
            Round5.AddMatch(10, 15, false, 44017); Round1.AddMatch(10, 16, false, 43912);
            Round1.AddMatch(11, 14, true, 43912); Round3.AddMatch(11, 15, true, 44002); Round5.AddMatch(11, 17, false, 44016);
            Round4.AddMatch(12, 16, true, 44009);
            Round4.AddMatch(13, 14, false, 44009); Round5.AddMatch(13, 16, false, 44014);
            Round2.AddMatch(14, 17, true, 43996);
            Round4.AddMatch(15, 17, true, 44007);

        }

        public List<FixturedRound> Rounds { get; private set; }
        private List<FixturedMatchupList> fixtured = null;
        public List<FixturedMatchupList> Fixtured {  get { return fixtured; } }
        public int NumberUnscheduled { get { { return fixtured.Count(f => f.Count == 0); } } }
        private Random rng = null;

        public Fixture()
        {
            Rounds = new List<FixturedRound>(17);
            Rounds.Add(Round1);
            Rounds.Add(Round2);
            Rounds.Add(Round3);
            Rounds.Add(Round4);
            Rounds.Add(Round5);
            //foreach (FixturedRound r in Rounds)
            //{
            //    foreach (Matchup m in r.Matches)
            //        isFixtured[m.Key] = true;
            //}
            for (int i = 6; i <= 17; i++)
                Rounds.Add(FixturedRound.RandomRound(i));
            //Rounds.Add(new FixturedRound(i));

            fixtured = new List<FixturedMatchupList>(153);
            for (int i = 0; i < 153; i++)
                fixtured.Add(new FixturedMatchupList(i));

            foreach (FixturedRound r in Rounds)
            {
                foreach (FixturedMatch fm in r.Matches)
                    fixtured[fm.Matchup.Key].Add(fm);
            }

            rng = new Random();
        }
        public int TimesFixtured(int key)
        {
            return fixtured[key].Count;
        }

        public void ImproveRandom()
        {
            // Find a round where a swap would make sense
            int max = fixtured.Max(l => l.Count);
            
            List<FixturedMatchupList> maxList = fixtured.Where(l => l.Count == max).ToList();
            FixturedMatch target = null;
            FixturedMatch swapper = null;
            while (target == null)
            {
                int rand1 = rng.Next(maxList.Count);
                int rand2 = rng.Next(max);
                target = maxList[rand1].Fixtured[rand2];
                // Is it already fixed in stone?
                if (target.Round.RoundNumber <= 5)
                {
                    target = null;
                    continue;
                }
                // Find another multi in the round
                swapper = null;
                int attempts = 0;
                while (swapper == null)
                {
                    attempts++;
                    int rand3 = rng.Next(9);
                    swapper = target.Round.Matches[rand3];
                    if (swapper == target)
                        swapper = null;
                    else if (fixtured[swapper.Matchup.Key].Count <= 1 && attempts < 20)
                        swapper = null;
                }
                if (swapper == null)
                {
                    target = null;
                    continue;
                }
                // Find the better swap
                Matchup mu1 = Matchup.FindMatchup(target.Matchup.Index1, swapper.Matchup.Index1);
                Matchup mu2 = Matchup.FindMatchup(target.Matchup.Index2, swapper.Matchup.Index2);
                Matchup mu3 = Matchup.FindMatchup(target.Matchup.Index1, swapper.Matchup.Index2);
                Matchup mu4 = Matchup.FindMatchup(target.Matchup.Index2, swapper.Matchup.Index1);
                FixturedMatch fm1, fm2;
                int comparison = fixtured[mu1.Key].Count + fixtured[mu2.Key].Count - (fixtured[mu3.Key].Count + fixtured[mu4.Key].Count);
                if (comparison > 0 || (comparison == 0 && rng.NextDouble() < 0.5))
                {
                    fm1 = new FixturedMatch(target.Round, mu3, rng.NextDouble() < 0.5);
                    fm2 = new FixturedMatch(target.Round, mu4, rng.NextDouble() < 0.5);
                }
                else
                {
                    fm1 = new FixturedMatch(target.Round, mu1, rng.NextDouble() < 0.5);
                    fm2 = new FixturedMatch(target.Round, mu2, rng.NextDouble() < 0.5);
                }
                target.Round.Matches.Remove(target);
                target.Round.Matches.Remove(swapper);
                target.Round.Matches.Add(fm1);
                target.Round.Matches.Add(fm2);
                fixtured[target.Matchup.Key].Remove(target);
                fixtured[swapper.Matchup.Key].Remove(swapper);
                fixtured[fm1.Matchup.Key].Add(fm1);
                fixtured[fm2.Matchup.Key].Add(fm2);
            }

        }

        public void BalanceHomeAway()
        {
            // Find an unbalanced team and remove some imbalance. Repeat until there is enough cardboard under all the legs

            int[] homeByClub = HomeByClubArray();
            while (homeByClub.Max() > 9 || homeByClub.Min() < 8)
            {
                // Negative index means too low, positive means too high
                List<int> imbalanced = new List<int>();
                for (int i = 0; i < homeByClub.Length; i++)
                {
                    if (homeByClub[i] < 8)
                        imbalanced.Add(-(i+1));
                    else if (homeByClub[i] > 9)
                        imbalanced.Add(i+1);
                }

                // Choose one at random
                int rand1 = rng.Next(imbalanced.Count());
                bool tooHigh = (imbalanced[rand1] > 0);
                int clubIndex = Math.Abs(imbalanced[rand1]) - 1;   // Remember we offset this earlier to make the sign meaningful
                // Find all their moveable games against clubs that aren't similarly imbalanced
                List<FixturedMatch> candidates = new List<FixturedMatch>();
                foreach (FixturedMatchupList list in Fixtured.Where(l => l.Matchup.Contains(clubIndex)))
                {
                    int oppoIndex = list.Matchup.Index1 + list.Matchup.Index2 - clubIndex;
                    if ((tooHigh && homeByClub[oppoIndex] < 9) || (!tooHigh && homeByClub[oppoIndex] > 8))
                    {
                        foreach (FixturedMatch fm in list.Fixtured.Where(f => f.Round.RoundNumber > 5))
                        {
                            if (tooHigh && (fm.IsHome && fm.Matchup.Index1 == clubIndex || !fm.IsHome && fm.Matchup.Index2 == clubIndex))
                                candidates.Add(fm);
                            else if (!tooHigh && (fm.IsHome && fm.Matchup.Index2 == clubIndex || !fm.IsHome && fm.Matchup.Index1 == clubIndex))
                                candidates.Add(fm);
                        }
                    }
                }
                int rand2 = rng.Next(candidates.Count());
                candidates[rand2].IsHome = !candidates[rand2].IsHome;

                homeByClub = HomeByClubArray();
            }
        }

        public int[] HomeByClubArray()
        {
            int[] homeByClub = new int[18];
            foreach (FixturedRound r in Rounds)
            {
                foreach (FixturedMatch fm in r.Matches)
                    homeByClub[fm.IsHome ? fm.Matchup.Club1.Index : fm.Matchup.Club2.Index]++;
            }
            return homeByClub;
        }

        public override string ToString()
        {
            string s = "";
            foreach (FixturedRound r in Rounds)
                s += r.ToString() + System.Environment.NewLine;
            return s;
        }

        public string ToCSV()
        {
            string s = "";
            foreach (FixturedRound r in Rounds)
                s += r.ToCSV();
            return s;
        }
    }
}
